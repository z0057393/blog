---

sidebar_label: 3. Open/Closed
sidebar_position: 3
-------------------

# üß© Open/Closed Principle (OCP)

Le **Open/Closed Principle (OCP)** est le deuxi√®me principe SOLID, formul√© par Bertrand Meyer et popularis√© par Robert C. Martin.
Il stipule :

> **Les entit√©s logicielles (classes, modules, fonctions, etc.) doivent √™tre ouvertes √† l'extension, mais ferm√©es √† la modification.**

Cela signifie qu'il doit √™tre possible d'ajouter de nouvelles fonctionnalit√©s **sans modifier le code existant**, ce qui r√©duit les risques de r√©gression.

---

## üõ†Ô∏è Pourquoi le OCP est-il important ?

| Avantage           | Explication                                                          |
| ------------------ | -------------------------------------------------------------------- |
| **Stabilit√©**      | Le code existant et test√© n'est pas modifi√©, ce qui limite les bugs. |
| **Extensibilit√©**  | Il est facile d'ajouter de nouvelles fonctionnalit√©s.                |
| **Maintenabilit√©** | Le code est plus facile √† comprendre et √† faire √©voluer.             |

> ‚ö° Note : Le respect de l'OCP permet de construire un syst√®me robuste, √©volutif et moins sujet aux erreurs lors des modifications.

---

## ü™Ñ Comment appliquer le OCP ?

Pour respecter l'OCP :

1. **Utiliser l'abstraction** : interfaces, classes abstraites, ou contrats clairs.
2. **Privil√©gier la composition et l'h√©ritage** pour √©tendre le comportement sans modifier les classes existantes.
3. **√âviter les conditions (`if/else`, `switch`) qui changent souvent**, en d√©l√©guant la logique √† des classes sp√©cialis√©es.

> ‚ÑπÔ∏è Astuce : chaque fois que vous sentez que vous devez modifier du code existant pour ajouter une fonctionnalit√©, demandez-vous si une nouvelle classe ou interface peut r√©soudre le probl√®me.

---

## üì© Exemple en C#

### ‚ùå Mauvaise pratique : Code ferm√© √† l'extension, ouvert √† la modification

```csharp
public class OrderProcessor
{
    public void ProcessOrder(Order order)
    {
        if (order.Type == "Standard")
        {
            // Logique de traitement pour une commande standard
        }
        else if (order.Type == "Express")
        {
            // Logique de traitement pour une commande express
        }
    }
}
```

> ‚ÑπÔ∏è Probl√®me : Ajouter un nouveau type de commande n√©cessite de modifier `OrderProcessor`, ce qui viole l'OCP et risque de cr√©er des r√©gressions.

---

### ‚úÖ Bonne pratique : Code ouvert √† l'extension, ferm√© √† la modification

```csharp
public interface IOrderProcessor
{
    void Process(Order order);
}

public class StandardOrderProcessor : IOrderProcessor
{
    public void Process(Order order)
    {
        // Logique de traitement pour une commande standard
    }
}

public class ExpressOrderProcessor : IOrderProcessor
{
    public void Process(Order order)
    {
        // Logique de traitement pour une commande express
    }
}

// Ajout d'un nouveau type de commande sans modifier le code existant
public class InternationalOrderProcessor : IOrderProcessor
{
    public void Process(Order order)
    {
        // Logique de traitement pour une commande internationale
    }
}

// Utilisation
public class OrderService
{
    private readonly Dictionary<string, IOrderProcessor> _processors;

    public OrderService()
    {
        _processors = new Dictionary<string, IOrderProcessor>
        {
            { "Standard", new StandardOrderProcessor() },
            { "Express", new ExpressOrderProcessor() },
            { "International", new InternationalOrderProcessor() }
        };
    }

    public void ProcessOrder(Order order)
    {
        _processors[order.Type].Process(order);
    }
}
```

> ‚ÑπÔ∏è Avantages :
>
> - Ajouter un nouveau type de commande : cr√©er simplement une nouvelle classe impl√©mentant `IOrderProcessor`.
> - Le code existant (`OrderService`) reste inchang√©.
> - Le syst√®me est flexible, extensible et conforme √† l'OCP.

---

## ‚ö° Probl√®mes fr√©quents / Causes probables

| Sympt√¥me                                                                     | Cause probable                        | Solution                                                                 |
| ---------------------------------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------------ |
| Ajout de nouvelles fonctionnalit√©s entra√Æne des modifications fr√©quentes     | Code ferm√© √† l'extension              | Introduire des interfaces et classes sp√©cialis√©es                        |
| Multiples conditions `if/else` dans la m√™me m√©thode                          | Logique m√©tier mal r√©partie           | Utiliser le polymorphisme pour d√©l√©guer la logique √† des classes d√©di√©es |
| Difficult√© √† tester certaines fonctionnalit√©s sans modifier le code existant | Couplage fort et manque d'abstraction | Appliquer OCP avec composition et interfaces                             |

---

## üéØ Conclusion

Le **Open/Closed Principle** permet de concevoir des syst√®mes logiciels stables, √©volutifs et faciles √† maintenir.
En utilisant l'abstraction et la composition, il est possible d'ajouter de nouvelles fonctionnalit√©s **sans risquer de casser le code existant**, garantissant ainsi la qualit√© et la flexibilit√© du logiciel.
