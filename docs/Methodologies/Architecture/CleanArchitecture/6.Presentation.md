---
sidebar_label: 6. Presentation
sidebar_position: 6
---

AprÃ¨s avoir explorÃ© les couches **Domain**, **Application** et **Infrastructure**, nous abordons maintenant la **couche Presentation**.
Câ€™est la couche la plus externe de la Clean Architecture et le **point de contact direct avec lâ€™utilisateur**.

Son rÃ´le est simple mais crucial : **traduire une interaction utilisateur en une intention mÃ©tier**, puis restituer le rÃ©sultat de maniÃ¨re adaptÃ©e.

---

## 6.1. Quâ€™est-ce que la couche Presentation ?

La couche Presentation a pour responsabilitÃ© de :

- GÃ©rer les **interfaces utilisateur** (API HTTP, Web, Mobile, CLI, etc.)
- Recevoir les **entrÃ©es utilisateur**
- Effectuer la **validation syntaxique et structurelle** des donnÃ©es
- Appeler les **Use Cases** de la couche Application
- Transformer les rÃ©sultats en **rÃ©ponses adaptÃ©es** au canal utilisÃ©

CaractÃ©ristiques clÃ©s :

- DÃ©pend uniquement de la couche **Application**
- Ne contient **aucune logique mÃ©tier**
- Ne connaÃ®t ni le Domain ni lâ€™Infrastructure
- Doit rester **mince, lisible et facilement remplaÃ§able**

ğŸ‘‰ La Presentation est une **porte dâ€™entrÃ©e**, jamais un lieu de dÃ©cision mÃ©tier.

---

## 6.2. RÃ´le rÃ©el de la couche Presentation

On rÃ©sume souvent cette couche Ã  des Â« contrÃ´leurs Â», mais son rÃ´le est plus prÃ©cis :

- Adapter le monde extÃ©rieur au modÃ¨le applicatif
- GÃ©rer les protocoles (HTTP, JSON, gRPC, CLI, etc.)
- ProtÃ©ger les Use Cases des dÃ©tails dâ€™interface

ğŸ‘‰ La couche Application ne devrait jamais savoir **comment** une action a Ã©tÃ© dÃ©clenchÃ©e.

---

## 6.3. Exemple en C# â€“ ASP.NET Core

Exemple dâ€™API HTTP pour **crÃ©er un utilisateur** :

```csharp
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly CreateUserUseCase _createUserUseCase;

    public UsersController(CreateUserUseCase createUserUseCase)
    {
        _createUserUseCase = createUserUseCase;
    }

    [HttpPost]
    public IActionResult Create([FromBody] CreateUserRequest request)
    {
        _createUserUseCase.Execute(request.Email);
        return Ok(new { Message = "Utilisateur crÃ©Ã© avec succÃ¨s" });
    }
}

public class CreateUserRequest
{
    public string Email { get; set; }
}
```

---

## 6.4. Ce que fait rÃ©ellement le contrÃ´leur

- ReÃ§oit une requÃªte HTTP
- DÃ©sÃ©rialise les donnÃ©es dâ€™entrÃ©e
- Effectue une validation **technique** (format, nullitÃ©, type)
- Appelle un **Use Case**
- Transforme le rÃ©sultat en rÃ©ponse HTTP

Ã€ aucun moment il ne :

- Valide des rÃ¨gles mÃ©tier
- Manipule directement des entitÃ©s du Domain
- AccÃ¨de Ã  la base de donnÃ©es

---

## 6.5. Validation et mapping

Bonnes pratiques :

- Valider les **entrÃ©es utilisateur** dans la Presentation
- Mapper les DTO de requÃªte vers les paramÃ¨tres des Use Cases
- Mapper les rÃ©sultats applicatifs vers des DTO de rÃ©ponse
- Garder ces transformations **simples et explicites**

La validation mÃ©tier, elle, reste dans le **Domain** ou lâ€™**Application**.

---

## 6.6. Erreurs frÃ©quentes Ã  Ã©viter

- Ajouter de la logique mÃ©tier dans les contrÃ´leurs
- Appeler directement lâ€™Infrastructure
- Faire dÃ©pendre la Presentation du Domain
- Transformer les contrÃ´leurs en services applicatifs

Un contrÃ´leur trop complexe est souvent le symptÃ´me dâ€™un mauvais dÃ©coupage.

---

## 6.7. Pourquoi la Presentation doit rester fine

- Elle change souvent (API v1/v2, nouvelle UI, nouveau protocole)
- Elle est dÃ©pendante des frameworks
- Elle doit Ãªtre facilement remplaÃ§able

ğŸ‘‰ Une bonne Clean Architecture permet de **changer complÃ¨tement lâ€™interface utilisateur sans toucher au mÃ©tier**.
