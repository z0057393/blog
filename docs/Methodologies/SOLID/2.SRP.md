---

sidebar_label: 2. SRP
sidebar_position: 2
-------------------

# ğŸ§© Single Responsibility Principle (SRP)

Le **Single Responsibility Principle (SRP)** est le premier des cinq principes SOLID.
Il stipule qu'**une classe ne doit avoir qu'une seule raison de changer**, c'est-Ã -dire qu'elle ne doit avoir qu'une seule responsabilitÃ©.

> ğŸ“ Astuce : Une responsabilitÃ© = une raison unique de modification. Si une classe change pour deux raisons ou plus, elle viole le SRP.

---

## ğŸ› ï¸ Pourquoi le SRP est-il important ?

Appliquer le SRP permet de :

| Avantage                         | Explication                                                                                |
| -------------------------------- | ------------------------------------------------------------------------------------------ |
| **MaintenabilitÃ©**               | Une classe avec une seule responsabilitÃ© est plus facile Ã  comprendre, tester et modifier. |
| **RÃ©utilisabilitÃ©**              | Les classes spÃ©cialisÃ©es peuvent Ãªtre rÃ©utilisÃ©es dans diffÃ©rents contextes.               |
| **RÃ©duction des effets de bord** | Modifier une classe nâ€™impacte pas dâ€™autres parties du systÃ¨me.                             |

> âš¡ Note : Le SRP est la base de la testabilitÃ© et de la robustesse du code. Une classe trop "polyvalente" devient rapidement fragile.

---

## ğŸª„ Comment appliquer le SRP ?

Pour respecter le SRP, suivez ces Ã©tapes :

1. **Identifier les responsabilitÃ©s**

   - Posez-vous la question : "Pourquoi cette classe pourrait-elle changer ?"
   - Chaque raison = une responsabilitÃ©

2. **DÃ©composer les classes**

   - SÃ©parez les responsabilitÃ©s en classes distinctes

3. **CrÃ©er des services spÃ©cialisÃ©s**

   - Persistance, notifications, calculs, etc.

> â„¹ï¸ Astuce : Une bonne pratique consiste Ã  donner un nom de classe qui reflÃ¨te **exactement sa responsabilitÃ© unique**.

---

## ğŸ“© Exemple en C#

### âŒ Mauvaise pratique : Une classe avec plusieurs responsabilitÃ©s

```csharp
public class Order
{
    public void CalculateTotal()
    {
        // Logique de calcul du total de la commande
    }

    public void SaveToDatabase()
    {
        // Logique de sauvegarde en base de donnÃ©es
    }

    public void SendEmailConfirmation()
    {
        // Logique d'envoi d'email de confirmation
    }
}
```

> â„¹ï¸ ProblÃ¨mes :
>
> - Difficile de tester le calcul du total sans toucher Ã  la persistance ou Ã  l'email
> - Tout changement dans la base de donnÃ©es ou lâ€™email peut casser la classe Order
> - La classe devient rapidement complexe et fragile

---

### âœ… Bonne pratique : Une classe, une responsabilitÃ©

```csharp
public class Order
{
    public decimal CalculateTotal()
    {
        // Logique de calcul du total de la commande
        return 0m;
    }
}

public class OrderRepository
{
    public void SaveToDatabase(Order order)
    {
        // Logique de sauvegarde en base de donnÃ©es
    }
}

public class EmailService
{
    public void SendEmailConfirmation(Order order)
    {
        // Logique d'envoi d'email de confirmation
    }
}
```

> â„¹ï¸ Avantages :
>
> - Chaque classe a **une seule responsabilitÃ©**
> - Tests unitaires simples et indÃ©pendants
> - Facile Ã  faire Ã©voluer : modifier lâ€™envoi dâ€™email ne touche pas Order

---

## âš¡ ProblÃ¨mes frÃ©quents / Causes probables

| SymptÃ´me                                                   | Cause probable                                             | Solution                                                 |
| ---------------------------------------------------------- | ---------------------------------------------------------- | -------------------------------------------------------- |
| Classe massive et difficile Ã  comprendre                   | Plusieurs responsabilitÃ©s dans la mÃªme classe              | DÃ©composer en classes spÃ©cialisÃ©es                       |
| Tests unitaires compliquÃ©s                                 | Logique mÃ©tier mÃªlÃ©e Ã  la persistance ou aux notifications | SÃ©parer les responsabilitÃ©s dans diffÃ©rents services     |
| Changements frÃ©quents qui cassent dâ€™autres fonctionnalitÃ©s | Couplage trop fort                                         | Isoler chaque responsabilitÃ© et injecter les dÃ©pendances |

---

## ğŸ¯ Conclusion

Le **Single Responsibility Principle** permet dâ€™obtenir un code :

- plus clair
- plus robuste
- plus facile Ã  maintenir et Ã  faire Ã©voluer

> ğŸ§© SRP est la **pierre angulaire de SOLID** : maÃ®triser une responsabilitÃ© par classe facilite lâ€™application des autres principes et amÃ©liore la qualitÃ© globale du code.
