---
sidebar_label: 3. Domain
sidebar_position: 3
---

AprÃ¨s avoir prÃ©sentÃ© la vision globale de la Clean Architecture, nous entrons maintenant dans son **cÅ“ur battant** â¤ï¸ : la **couche Domain**.

Câ€™est **la couche la plus importante et la plus stable** de toute lâ€™architecture.
Elle contient ce qui donne rÃ©ellement de la valeur Ã  lâ€™application : **la logique mÃ©tier pure**.

ğŸ‘‰ Tout le reste (UI, base de donnÃ©es, frameworks) existe **pour servir le Domain**, jamais lâ€™inverse.

---

## 3.1. Quâ€™est-ce que la couche Domain ?

Le **Domain** reprÃ©sente le **mÃ©tier**, rien de plus, rien de moins.

Il rÃ©pond Ã  des questions fondamentales :

- Quels sont les concepts clÃ©s du mÃ©tier ?
- Quelles rÃ¨gles doivent toujours Ãªtre respectÃ©es ?
- Comment ces concepts interagissent entre eux ?

La couche Domain est **totalement indÃ©pendante** :

- âŒ pas dâ€™UI
- âŒ pas de base de donnÃ©es
- âŒ pas de framework
- âŒ pas de rÃ©seau

ğŸ‘‰ Elle doit pouvoir Ãªtre comprise, testÃ©e et exÃ©cutÃ©e **en isolation complÃ¨te**.

---

## 3.2. Les composants principaux du Domain

La couche Domain sâ€™articule gÃ©nÃ©ralement autour de trois types de composants.

---

### 3.2.1. Les EntitÃ©s (Entities)

Les **entitÃ©s** reprÃ©sentent des objets mÃ©tier ayant une **identitÃ© propre** et une **durÃ©e de vie**.

Exemples classiques :

- `User` avec un identifiant unique et des rÃ¨gles liÃ©es Ã  son Ã©tat
- `Invoice` avec des rÃ¨gles de calcul de taxes
- `Order` avec des contraintes sur ses statuts

ğŸ‘‰ Une entitÃ© doit toujours Ãªtre **dans un Ã©tat valide**.

---

### 3.2.2. Les Objets de Valeur (Value Objects)

Les **objets de valeur** reprÃ©sentent des concepts mÃ©tier **sans identitÃ© propre**.
Ils sont dÃ©finis uniquement par leurs attributs.

Exemples :

- `EmailAddress`
- `Money`
- `Address`

ğŸ‘‰ Ils permettent dâ€™Ã©viter les types primitifs trop pauvres (`string`, `decimal`, etc.).

---

### 3.2.3. Les Services de Domaine (Domain Services)

Certaines rÃ¨gles mÃ©tier ne trouvent pas naturellement leur place dans une seule entitÃ©.

Dans ce cas, on utilise un **service de domaine**.

Exemples :

- calculer le total dâ€™une commande avec plusieurs rÃ¨gles
- appliquer des politiques de remise complexes

âš ï¸ Un service de domaine ne doit **jamais devenir un fourre-tout**.

---

## 3.3. Ce que le Domain ne doit **jamais** contenir

Pour rester pur et stable, le Domain doit Ãªtre strictement protÃ©gÃ©.

Il ne doit contenir **aucune trace** de :

- Base de donnÃ©es
- ORM
- API externes
- UI
- Frameworks

ğŸ‘‰ Si un dÃ©tail technique apparaÃ®t dans le Domain, câ€™est souvent un **signal dâ€™alerte** ğŸš¨.

---

## 3.4. Exemple simple en C#

Voici un exemple volontairement simple illustrant les principaux concepts.

```csharp
// Value Object
public class EmailAddress
{
    public string Value { get; }

    public EmailAddress(string value)
    {
        if (!value.Contains("@"))
            throw new ArgumentException("Email invalide", nameof(value));

        Value = value;
    }
}

// Entity
public class User
{
    public Guid Id { get; }
    public EmailAddress Email { get; }

    public User(Guid id, EmailAddress email)
    {
        Id = id;
        Email = email;
    }
}

// Entity
public class Order
{
    public IReadOnlyList<OrderItem> Items { get; }
    public bool HasDiscount { get; }

    public Order(IReadOnlyList<OrderItem> items, bool hasDiscount)
    {
        Items = items;
        HasDiscount = hasDiscount;
    }
}

public class OrderItem
{
    public decimal Price { get; }

    public OrderItem(decimal price)
    {
        Price = price;
    }
}

// Domain Service
public class OrderService
{
    public decimal CalculateTotal(Order order)
    {
        var total = order.Items.Sum(item => item.Price);

        if (order.HasDiscount)
            total *= 0.9m;

        return total;
    }
}
```

Dans cet exemple :

- la logique mÃ©tier est centralisÃ©e
- aucune dÃ©pendance technique nâ€™est introduite
- tout est **facilement testable**

---

## 3.5. Pourquoi le Domain est au centre â¤ï¸

- ğŸª¨ **StabilitÃ©** : il change moins souvent que lâ€™UI ou lâ€™infrastructure
- ğŸ” **RÃ©utilisabilitÃ©** : il peut servir plusieurs interfaces
- ğŸ›¡ï¸ **Protection** : il est isolÃ© des choix techniques

> En Clean Architecture, **protÃ©ger le Domain, câ€™est protÃ©ger lâ€™application**.
