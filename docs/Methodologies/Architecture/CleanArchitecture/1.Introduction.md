---
sidebar_label: 1. Introduction
sidebar_position: 1
---

La **Clean Architecture** est bien plus quâ€™une simple faÃ§on de ranger des fichiers dans des dossiers.
Câ€™est avant tout un **Ã©tat dâ€™esprit** ğŸ§ âœ¨ : une maniÃ¨re de penser le logiciel pour quâ€™il reste comprÃ©hensible, testable et Ã©volutifâ€¦ mÃªme quand le projet grandit.

Dans ce premier article, on va surtout sâ€™intÃ©resser au **pourquoi** :

- Pourquoi la Clean Architecture existe,
- Quels problÃ¨mes concrets elle cherche Ã  rÃ©soudre,
- Et surtout **quand elle est rÃ©ellement pertinente**.

Pas de recettes magiques ici, mais des idÃ©es solides pour construire des applications qui tiennent dans le temps ğŸ—ï¸.

---

## 1.1. Quâ€™est-ce que la Clean Architecture ?

La Clean Architecture est une approche popularisÃ©e par **Robert C. Martin (Uncle Bob)**.
Son objectif principal est simple Ã  Ã©noncer, mais exigeant Ã  appliquer :

> **ProtÃ©ger le cÅ“ur mÃ©tier des dÃ©tails techniques.**

ConcrÃ¨tement, elle vise Ã  ce que :

- Les rÃ¨gles mÃ©tier soient **indÃ©pendantes** des frameworks
- Les dÃ©cisions techniques puissent Ã©voluer sans tout casser
- Le code soit plus simple Ã  tester

Deux notions sont absolument centrales :

- la **sÃ©paration des responsabilitÃ©s**
- le **contrÃ´le des dÃ©pendances**

ğŸ‘‰ Et point important : la Clean Architecture **ne dicte pas**

- âŒ un langage
- âŒ un framework
- âŒ une arborescence de dossiers universelle

Elle fournit avant tout des **principes**, Ã  adapter au contexte.

---

## 1.2. Pourquoi la Clean Architecture existe

Beaucoup de projets commencent proprementâ€¦ puis, petit Ã  petit, deviennent difficiles Ã  faire Ã©voluer ğŸ˜¬.

Les symptÃ´mes sont souvent les mÃªmes :

- ğŸ¤¯ de la logique mÃ©tier partout (contrÃ´leurs, services, repositories)
- ğŸ”— un couplage fort aux frameworks
- ğŸ§ª des tests compliquÃ©s, lents ou absents
- ğŸ˜± une peur permanente du changement : _Â« si je touche Ã  Ã§a, tout casse Â»_

La Clean Architecture tente de rÃ©pondre Ã  ces problÃ¨mes en introduisant des **frontiÃ¨res claires** et des **dÃ©pendances explicites**.

Lâ€™idÃ©e clÃ© peut se rÃ©sumer ainsi :

> **Ce qui change souvent ne doit pas impacter ce qui change rarement.**

Or, dans la majoritÃ© des projets :

- lâ€™UI change ğŸ”„
- la base de donnÃ©es change ğŸ”„
- les services externes changent ğŸ”„

ğŸ‘‰ mais le **mÃ©tier**, lui, Ã©volue beaucoup plus lentement.

---

## 1.3. Lâ€™architecture, ce sont des dÃ©cisions

Lâ€™architecture ne se limite pas Ã  un schÃ©ma ou Ã  une structure de dossiers.
Elle correspond Ã  des **choix fondamentaux** :

- Qui dÃ©pend de qui ?
- OÃ¹ vit la logique mÃ©tier ?
- Qui a le droit de parler Ã  la base de donnÃ©es ?
- Comment le cÅ“ur de lâ€™application communique avec lâ€™extÃ©rieur ?

La Clean Architecture aide Ã  **rendre ces dÃ©cisions explicites**, plutÃ´t que de les laisser apparaÃ®tre par accident au fil du code.

---

## 1.4. AperÃ§u des couches utilisÃ©es dans cette sÃ©rie

Dans cette sÃ©rie, nous allons utiliser une sÃ©paration classique en quatre couches :

![alt text](clean_architecture.png "Clean Architecture schema")

- **Presentation** ğŸ–¥ï¸
  Interaction avec lâ€™utilisateur (UI, API, contrÃ´leurs).

- **Application** ğŸ¯
  Orchestration des cas dâ€™usage.

- **Domain** â¤ï¸
  Le cÅ“ur du mÃ©tier : rÃ¨gles, invariants, concepts clÃ©s.

- **Infrastructure** âš™ï¸
  Les dÃ©tails techniques (base de donnÃ©es, frameworks, services externes).

âš ï¸ RÃ¨gle essentielle : **les dÃ©pendances pointent toujours vers lâ€™intÃ©rieur**, en direction du Domain.

Chaque couche sera dÃ©taillÃ©e dans les prochains articles.

---

## 1.5. Ce que la Clean Architecture nâ€™est pas

Il est important de lever quelques malentendus courants.

La Clean Architecture nâ€™est **pas** :

- Une solution miracle
- Un remplaÃ§ant de la rÃ©flexion et de la conception
- Une garantie automatique de qualitÃ©
- Toujours nÃ©cessaire

Elle peut Ãªtre excessive pour :

- des projets trÃ¨s simples
- des prototypes jetables
- des applications CRUD sans logique mÃ©tier significative

ğŸ‘‰ Mal appliquÃ©e, elle peut mÃªme **ajouter de la complexitÃ© inutile**.

---

## 1.6. Quand la Clean Architecture est-elle pertinente ?

Elle devient particuliÃ¨rement intÃ©ressante lorsque :

- La logique mÃ©tier est riche ou complexe
- Lâ€™application est pensÃ©e pour durer
- Plusieurs interfaces partagent le mÃªme cÅ“ur mÃ©tier
- La testabilitÃ© est un vrai enjeu
- On veut rÃ©duire la dÃ©pendance aux frameworks

Elle aide aussi bien Ã  faire Ã©voluer le **code** que les **Ã©quipes**.

---

## 1.7. Un Ã©tat dâ€™esprit avant tout

Le point essentiel Ã  retenir est probablement celui-ci :

> La Clean Architecture nâ€™est pas une question de diagrammes,
> mais de **protection de ce qui a le plus de valeur : la logique mÃ©tier**.

Ces principes ne sont pas dogmatiques :

- ils peuvent Ãªtre appliquÃ©s progressivement
- adaptÃ©s au contexte
- et parfois contournÃ©s lorsque câ€™est justifiÃ©
