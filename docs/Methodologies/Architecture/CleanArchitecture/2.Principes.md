---
sidebar_label: 2. Principes
sidebar_position: 2
---

Dans lâ€™article prÃ©cÃ©dent, nous avons vu **pourquoi** la Clean Architecture existe et dans quels contextes elle prend tout son sens.
Ici, on va entrer dans le cÅ“ur du sujet : **les principes qui la font rÃ©ellement fonctionner**.

Ces principes sont indÃ©pendants des langages et des frameworks.
Ils servent de **boussole** pour prendre de bonnes dÃ©cisions quand lâ€™application grossit et que la complexitÃ© augmente.

---

## 2.1. La sÃ©paration des responsabilitÃ©s

Chaque partie du systÃ¨me doit avoir **un rÃ´le clair et limitÃ©**.

ConcrÃ¨tement :

- ğŸ–¥ï¸ la **Presentation** gÃ¨re lâ€™interaction avec lâ€™extÃ©rieur
- ğŸ¯ lâ€™**Application** orchestre les cas dâ€™usage
- â¤ï¸ le **Domain** contient la logique mÃ©tier
- âš™ï¸ lâ€™**Infrastructure** sâ€™occupe des dÃ©tails techniques

Quand les responsabilitÃ©s sont mÃ©langÃ©es :

- Le code devient difficile Ã  lire
- Une modification entraÃ®ne des effets de bord
- Les tests deviennent pÃ©nibles Ã  Ã©crire

La Clean Architecture impose donc des **frontiÃ¨res explicites** entre ces responsabilitÃ©s.

---

## 2.2. La rÃ¨gle de dÃ©pendance

Câ€™est **le principe central** de la Clean Architecture.

> **Les dÃ©pendances doivent toujours pointer vers lâ€™intÃ©rieur.**

Dans lâ€™approche utilisÃ©e ici :

- Presentation â¡ï¸ Application
- Application â¡ï¸ Domain
- Infrastructure â¡ï¸ Application
- âŒ Domain â¡ï¸ personne

![alt text](clean_architecture.png "Clean Architecture schema")

ğŸ‘‰ Le **Domain est totalement isolÃ©**.
Il ne connaÃ®t ni framework, ni base de donnÃ©es, ni interface utilisateur.

Ce principe protÃ¨ge ce qui a le plus de valeur : la logique mÃ©tier.

---

## 2.3. Les rÃ¨gles mÃ©tier avant tout

La Clean Architecture place le **mÃ©tier au centre** de lâ€™application â¤ï¸.

On distingue gÃ©nÃ©ralement deux niveaux de rÃ¨gles :

- **RÃ¨gles mÃ©tier (Domain rules)**
  Invariants, concepts, rÃ¨gles fondamentales du mÃ©tier.

- **RÃ¨gles applicatives (Application rules)**
  EnchaÃ®nement des cas dâ€™usage, validation des scÃ©narios.

Les dÃ©tails techniques doivent **sâ€™adapter au mÃ©tier**, jamais lâ€™inverse.

ğŸ‘‰ Changer de framework, de base de donnÃ©es ou de protocole ne devrait pas forcer Ã  rÃ©Ã©crire la logique mÃ©tier.

---

## 2.4. Lâ€™indÃ©pendance des frameworks

Un framework est un **outil**, pas une fondation.

Dans une Clean Architecture :

- Le framework est utilisÃ©, mais reste pÃ©riphÃ©rique
- Le cÅ“ur de lâ€™application peut exister sans lui
- Il est remplaÃ§able

Cela permet :

- De rÃ©duire le couplage
- De tester sans dÃ©pendre du framework
- De mieux encaisser les Ã©volutions technologiques

---

## 2.5. Lâ€™indÃ©pendance des interfaces

Les interfaces changent souvent :

- API REST
- application web
- application mobile
- CLI

La Clean Architecture permet de :

- changer lâ€™UI sans toucher au mÃ©tier
- partager les mÃªmes cas dâ€™usage entre plusieurs interfaces
- tester la logique sans interface graphique

ğŸ‘‰ La Presentation est une **porte dâ€™entrÃ©e**, pas un lieu de dÃ©cision mÃ©tier.

---

## 2.6. Lâ€™indÃ©pendance de la persistance

La base de donnÃ©es est un **dÃ©tail dâ€™implÃ©mentation**.

Dans une Clean Architecture :

- le Domain ignore totalement la persistance
- lâ€™Application dÃ©pend dâ€™**abstractions** (Ports)
- lâ€™Infrastructure fournit les implÃ©mentations

```
Application â”€â”€â–º Repository (interface)
                     â–²
                     â”‚
               Infrastructure
```

Changer de base de donnÃ©es ne doit pas impacter les rÃ¨gles mÃ©tier ou applicatives.

---

## 2.7. Lâ€™inversion de dÃ©pendance

Pour respecter la rÃ¨gle de dÃ©pendance, la Clean Architecture sâ€™appuie fortement sur l'**inversion de dÃ©pendance**.

Cela implique :

- Les couches internes dÃ©finissent les interfaces
- Les couches externes implÃ©mentent ces interfaces
- Le code dÃ©pend dâ€™abstractions, pas de dÃ©tails concrets

Ainsi, le Domain et lâ€™Application **gardent le contrÃ´le** de leurs dÃ©pendances.

---

## 2.8. La testabilitÃ© comme moteur de conception

Un bon indicateur dâ€™une architecture saine est sa **testabilitÃ©** ğŸ§ª.

La Clean Architecture permet :

- De tester le Domain sans infrastructure
- De tester les cas dâ€™usage sans framework
- Dâ€™avoir des tests rapides, fiables et lisibles

ğŸ‘‰ Si un composant est difficile Ã  tester, câ€™est souvent un signal que les responsabilitÃ©s sont mal rÃ©parties.

---

## 2.9. En rÃ©sumÃ©

Les principes fondamentaux de la Clean Architecture peuvent se rÃ©sumer ainsi :

- SÃ©parer clairement les responsabilitÃ©s
- Faire pointer les dÃ©pendances vers le cÅ“ur mÃ©tier
- Donner la prioritÃ© aux rÃ¨gles mÃ©tier
- Isoler les dÃ©tails techniques
- Favoriser la testabilitÃ© et lâ€™Ã©volutivitÃ©
