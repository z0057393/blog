---

sidebar_label: 4. Liskow Substitution
sidebar_position: 4
-------------------

# üß© Liskov Substitution Principle (LSP)

Le **Liskov Substitution Principle (LSP)** est le troisi√®me principe SOLID, introduit par Barbara Liskov.
Il stipule :

> **Les objets d'une classe d√©riv√©e doivent pouvoir remplacer les objets de la classe de base sans alt√©rer le bon fonctionnement du programme.**

Autrement dit, une sous-classe doit √™tre substituable √† sa classe parente sans comportements inattendus.

---

## üõ†Ô∏è Pourquoi le LSP est-il important ?

| Avantage            | Explication                                                    |
| ------------------- | -------------------------------------------------------------- |
| **Robustesse**      | √âvite les bugs li√©s √† une mauvaise hi√©rarchie de classes.      |
| **Maintenabilit√©**  | Facilite la compr√©hension et l'√©volution du code.              |
| **R√©utilisabilit√©** | Permet d'utiliser les sous-classes de mani√®re interchangeable. |

> ‚ö° Note : Respecter le LSP permet d‚Äô√©crire des hi√©rarchies s√ªres et pr√©visibles.

---

## ü™Ñ Comment appliquer le LSP ?

Pour respecter le LSP, il faut :

- **Ne pas renforcer les pr√©conditions** dans les sous-classes.
- **Ne pas affaiblir les postconditions** dans les sous-classes.
- **Ne pas changer les invariants** de la classe de base.
- **√âviter de lever des exceptions inattendues** dans les sous-classes.

> ‚ÑπÔ∏è Astuce : Si une sous-classe ne peut pas respecter toutes les r√®gles de la classe parente, il vaut mieux repenser la hi√©rarchie ou utiliser la composition.

---

## üì© Exemple en C#

### ‚ùå Mauvaise pratique : Violation du LSP

```csharp
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public int Area => Width * Height;
}

public class Square : Rectangle
{
    public override int Width
    {
        get => base.Width;
        set { base.Width = base.Height = value; }
    }

    public override int Height
    {
        get => base.Height;
        set { base.Width = base.Height = value; }
    }
}

// Utilisation
public void TestArea(Rectangle rectangle)
{
    rectangle.Width = 5;
    rectangle.Height = 4;
    Console.WriteLine($"Aire attendue : 20, aire calcul√©e : {rectangle.Area}");
}

// Probl√®me : Si on passe un Square, le r√©sultat sera 16 au lieu de 20 !
```

> ‚ÑπÔ∏è Probl√®me : Un `Square` n'est pas substituable √† un `Rectangle` car il modifie le comportement attendu.

---

### ‚úÖ Bonne pratique : Respect du LSP

```csharp
public abstract class Shape
{
    public abstract int Area { get; }
}

public class Rectangle : Shape
{
    public int Width { get; set; }
    public int Height { get; set; }

    public override int Area => Width * Height;
}

public class Square : Shape
{
    public int Side { get; set; }

    public override int Area => Side * Side;
}

// Utilisation
public void PrintArea(Shape shape)
{
    Console.WriteLine($"Aire : {shape.Area}");
}

// Rectangle et Square sont interchangeables en tant que Shape.
```

> ‚ÑπÔ∏è Avantages :
>
> - Chaque classe a un comportement coh√©rent et pr√©visible.
> - Le code client (`PrintArea`) fonctionne correctement avec n'importe quelle sous-classe de `Shape`.
> - Pas de surprises lors de l'ex√©cution.

---

## ‚ö° Probl√®mes fr√©quents / Causes probables

| Sympt√¥me                                                        | Cause probable                                 | Solution                                                                        |
| --------------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------------------------- |
| Sous-classe change le comportement attendu de la classe parente | Pr√©conditions/postconditions non respect√©es    | Revoir la hi√©rarchie ou utiliser la composition                                 |
| Bugs subtils lors de l'utilisation polymorphique                | M√©thodes qui l√®vent des exceptions inattendues | Garantir que toutes les m√©thodes respectent les invariants de la classe de base |
| Difficult√© √† substituer les objets                              | Sous-classes trop sp√©cifiques ou coupl√©es      | Cr√©er des classes abstraites ou interfaces g√©n√©riques                           |

---

## üéØ Conclusion

Le **Liskov Substitution Principle** garantit que l'h√©ritage est utilis√© de mani√®re s√ªre et pr√©visible.
En respectant ce principe, on √©vite les bugs subtils et on rend le code plus robuste, maintenable et r√©utilisable.
