---

sidebar_label: 5. Interface Segregation
sidebar_position: 5
-------------------

# üß© Interface Segregation Principle (ISP)

Le **Interface Segregation Principle (ISP)** est le quatri√®me principe SOLID.
Il stipule :

> **Les clients ne doivent pas √™tre forc√©s de d√©pendre d'interfaces qu'ils n'utilisent pas.**

Autrement dit, il vaut mieux avoir plusieurs interfaces sp√©cifiques plut√¥t qu'une seule interface g√©n√©rale pour √©viter que les classes impl√©mentent des m√©thodes inutiles.

---

## üõ†Ô∏è Pourquoi l'ISP est-il important ?

| Avantage                               | Explication                                                      |
| -------------------------------------- | ---------------------------------------------------------------- |
| **R√©duction des d√©pendances inutiles** | Les classes n'impl√©mentent que ce dont elles ont besoin.         |
| **Meilleure maintenabilit√©**           | Les interfaces sont claires et faciles √† modifier.               |
| **√âvitement des "fat interfaces"**     | Une interface trop large devient difficile √† g√©rer et √† √©tendre. |

> ‚ö° Note : Des interfaces fines permettent de limiter les risques de couplage inutile et facilitent l‚Äô√©volution du code.

---

## ü™Ñ Comment appliquer l'ISP ?

Pour respecter l'ISP :

1. **D√©composer les interfaces** en plusieurs interfaces sp√©cifiques.
2. **√âviter les interfaces "fourre-tout"** qui regroupent trop de responsabilit√©s.
3. **Privil√©gier la composition d'interfaces** plut√¥t que l'h√©ritage multiple.

> ‚ÑπÔ∏è Astuce : Chaque interface doit repr√©senter une responsabilit√© unique et clairement d√©finie.

---

## üì© Exemple en C#

### ‚ùå Mauvaise pratique : Une interface trop large

```csharp
public interface IWorker
{
    void Work();
    void Eat();
    void Sleep();
}

public class HumanWorker : IWorker
{
    public void Work() { /* ... */ }
    public void Eat() { /* ... */ }
    public void Sleep() { /* ... */ }
}

// Probl√®me : Un robot n'a pas besoin de manger ou de dormir !
public class RobotWorker : IWorker
{
    public void Work() { /* ... */ }
    public void Eat() { throw new NotImplementedException(); }
    public void Sleep() { throw new NotImplementedException(); }
}
```

> ‚ÑπÔ∏è Probl√®me : `RobotWorker` est forc√© d‚Äôimpl√©menter des m√©thodes inutiles (`Eat`, `Sleep`), violant l'ISP.

---

### ‚úÖ Bonne pratique : Interfaces segreg√©es

```csharp
public interface IWorkable
{
    void Work();
}

public interface IEatable
{
    void Eat();
}

public interface ISleepable
{
    void Sleep();
}

// Une classe n'impl√©mente que les interfaces n√©cessaires
public class HumanWorker : IWorkable, IEatable, ISleepable
{
    public void Work() { /* ... */ }
    public void Eat() { /* ... */ }
    public void Sleep() { /* ... */ }
}

// Un robot n'impl√©mente que ce qui est n√©cessaire
public class RobotWorker : IWorkable
{
    public void Work() { /* ... */ }
}
```

> ‚ÑπÔ∏è Avantages :
>
> - Chaque classe impl√©mente uniquement les interfaces pertinentes.
> - Code plus clair et facile √† maintenir.
> - Pas de m√©thodes inutiles ou jet√©es (`NotImplementedException`).

---

## ‚ö° Probl√®mes fr√©quents / Causes probables

| Sympt√¥me                                          | Cause probable                                   | Solution                                                                                |
| ------------------------------------------------- | ------------------------------------------------ | --------------------------------------------------------------------------------------- |
| Classe forc√©e d‚Äôimpl√©menter des m√©thodes inutiles | Interface trop large                             | D√©composer l‚Äôinterface en interfaces plus petites                                       |
| Difficult√© √† faire √©voluer les interfaces         | Trop de responsabilit√©s dans une seule interface | Appliquer ISP et cr√©er plusieurs interfaces sp√©cifiques                                 |
| Code peu clair et difficile √† maintenir           | Couplage inutile entre classes et m√©thodes       | Privil√©gier la composition d‚Äôinterfaces et impl√©menter uniquement ce qui est n√©cessaire |

---

## üéØ Conclusion

Le **Interface Segregation Principle** permet de concevoir des interfaces fines, adapt√©es aux besoins r√©els des classes.
En √©vitant les interfaces trop larges, le code devient plus robuste, plus flexible et plus facile √† maintenir.
