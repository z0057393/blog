---

sidebar_label: 6. Dependency Inversion
sidebar_position: 6
-------------------

# üß© Dependency Inversion Principle (DIP)

Le **Dependency Inversion Principle (DIP)** est le cinqui√®me et dernier principe SOLID.
Il se compose de deux r√®gles principales :

1. **Les modules de haut niveau ne doivent pas d√©pendre des modules de bas niveau. Les deux doivent d√©pendre d'abstractions.**
2. **Les abstractions ne doivent pas d√©pendre des d√©tails. Les d√©tails doivent d√©pendre des abstractions.**

En r√©sum√©, il faut **inverser les d√©pendances** : le code doit d√©pendre d'interfaces plut√¥t que de classes concr√®tes.

---

## üõ†Ô∏è Pourquoi le DIP est-il important ?

| Avantage        | Explication                                                                        |
| --------------- | ---------------------------------------------------------------------------------- |
| **D√©couplage**  | R√©duit les d√©pendances directes entre les classes, facilitant l'√©volution du code. |
| **Testabilit√©** | Permet de mocker facilement les d√©pendances pour les tests unitaires.              |
| **Flexibilit√©** | On peut changer les impl√©mentations sans modifier le code client.                  |

> ‚ö° Note : Le DIP est essentiel pour construire des architectures modulaires et maintenables.

---

## ü™Ñ Comment appliquer le DIP ?

Pour respecter le DIP :

1. **D√©finir des interfaces** pour les services ou d√©pendances.
2. **Injecter les d√©pendances** via constructeur, m√©thode ou propri√©t√©.
3. **√âviter d'instancier directement** des classes concr√®tes dans les modules de haut niveau.

> ‚ÑπÔ∏è Astuce : Chaque classe de haut niveau devrait interagir uniquement avec des abstractions, pas avec des impl√©mentations concr√®tes.

---

## üì© Exemple en C#

### ‚ùå Mauvaise pratique : D√©pendance directe √† une classe concr√®te

```csharp
// Module de bas niveau
public class EmailService
{
    public void SendEmail(string message)
    {
        // Logique d'envoi d'email
    }
}

// Module de haut niveau (d√©pend directement de EmailService)
public class OrderProcessor
{
    private readonly EmailService _emailService = new EmailService();

    public void ProcessOrder()
    {
        // Traitement de la commande
        _emailService.SendEmail("Votre commande a √©t√© trait√©e.");
    }
}
```

> ‚ÑπÔ∏è Probl√®me : `OrderProcessor` d√©pend directement d'une classe concr√®te, rendant le code rigide et difficile √† tester.

---

### ‚úÖ Bonne pratique : D√©pendance invers√©e via une interface

```csharp
// Abstraction (interface)
public interface IMessageService
{
    void Send(string message);
}

// Module de bas niveau (impl√©mente l'interface)
public class EmailService : IMessageService
{
    public void Send(string message)
    {
        // Logique d'envoi d'email
    }
}

// Autre impl√©mentation possible
public class SmsService : IMessageService
{
    public void Send(string message)
    {
        // Logique d'envoi de SMS
    }
}

// Module de haut niveau (d√©pend de l'abstraction)
public class OrderProcessor
{
    private readonly IMessageService _messageService;

    // Injection de d√©pendance via le constructeur
    public OrderProcessor(IMessageService messageService)
    {
        _messageService = messageService;
    }

    public void ProcessOrder()
    {
        _messageService.Send("Votre commande a √©t√© trait√©e.");
    }
}

// Utilisation
var emailService = new EmailService();
var orderProcessor = new OrderProcessor(emailService);

// Ou avec un autre service
var smsService = new SmsService();
var orderProcessorSms = new OrderProcessor(smsService);
```

> ‚ÑπÔ∏è Avantages :
>
> - `OrderProcessor` d√©pend d'une abstraction (`IMessageService`) et non d'une impl√©mentation concr√®te.
> - Facile de changer le service de messagerie sans modifier le code.
> - Tests unitaires simples gr√¢ce aux mocks.

---

## ‚ö° Probl√®mes fr√©quents / Causes probables

| Sympt√¥me                                       | Cause probable                             | Solution                                                           |
| ---------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------ |
| Code rigide et difficile √† tester              | D√©pendance directe √† des classes concr√®tes | Introduire des interfaces et injecter les d√©pendances              |
| Modification d'un service casse le code client | Couplage fort entre haut et bas niveau     | Appliquer le DIP et d√©pendre uniquement d'abstractions             |
| Tests unitaires complexes ou impossibles       | Absence d'abstractions                     | Utiliser des interfaces ou classes abstraites pour les d√©pendances |

---

## üéØ Conclusion

Le **Dependency Inversion Principle** permet de concevoir des syst√®mes modulaires, flexibles et testables.
En d√©pendant d'abstractions plut√¥t que de d√©tails, le code devient plus robuste, maintenable et √©volutif.
