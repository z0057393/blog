---
sidebar_label: 4. Application
sidebar_position: 4
---

Apr√®s avoir explor√© le **Domain** ‚Äî le c≈ìur m√©tier ‚ù§Ô∏è ‚Äî nous allons maintenant nous int√©resser √† la **couche Application**.

Si le Domain d√©finit _ce qui est vrai_ dans le m√©tier, la couche Application d√©finit _ce que le syst√®me fait concr√®tement_ üéØ.

Elle orchestre les **cas d‚Äôusage**, coordonne les entit√©s du Domain et fait le lien entre le c≈ìur m√©tier et le monde ext√©rieur, **sans jamais d√©pendre de la technique**.

---

## 4.1. Qu‚Äôest-ce que la couche Application ?

La couche **Application** est responsable de la logique **applicative**.

Elle sert principalement √† :

- Orchestrer les **Use Cases**
- D√©finir des **interfaces (ports)** vers l‚Äôext√©rieur
- Appliquer des r√®gles li√©es au **contexte applicatif**
- Coordonner plusieurs objets du Domain

‚ö†Ô∏è Point cl√© :

> La couche Application **d√©pend du Domain**, mais **ne d√©pend jamais** de l‚ÄôInfrastructure ni de la Presentation.

---

## 4.2. R√¥le de la couche Application dans l‚Äôarchitecture

On peut r√©sumer son r√¥le ainsi :

```
Presentation  ‚îÄ‚îÄ‚ñ∫  Application  ‚îÄ‚îÄ‚ñ∫  Domain
                        ‚ñ≤
                        ‚îÇ
                  Infrastructure
```

üëâ Elle est le **point de passage oblig√©** entre l‚Äôext√©rieur et le Domain.

---

## 4.3. Les composants principaux

La couche Application est g√©n√©ralement compos√©e de deux types d‚Äô√©l√©ments :

---

### 4.3.1. Les Use Cases (Application Services)

Les **Use Cases** repr√©sentent les **sc√©narios m√©tiers** que l‚Äôapplication doit g√©rer.

Ils r√©pondent √† des questions tr√®s concr√®tes :

- Comment cr√©er un utilisateur ?
- Comment passer une commande ?
- Comment valider un paiement ?

üëâ Un Use Case raconte une **histoire m√©tier pr√©cise**, du d√©but √† la fin.

---

### 4.3.2. Les Interfaces (Ports)

La couche Application d√©finit des **interfaces** pour tout ce qui sort de son p√©rim√®tre :

- `IUserRepository`
- `IOrderRepository`
- `IPaymentGateway`

Ces interfaces sont appel√©es **ports**.

- Elles sont d√©finies c√¥t√© Application
- Elles sont impl√©ment√©es c√¥t√© Infrastructure

Ainsi, l‚ÄôApplication d√©pend uniquement **d‚Äôabstractions**, jamais de d√©tails techniques.

---

## 4.4. Exemple simple : cr√©er un utilisateur

Voici un Use Case minimaliste illustrant ce principe.

```csharp
// Port d√©fini dans la couche Application
public interface IUserRepository
{
    User? GetByEmail(EmailAddress email);
    void Add(User user);
}

// Use Case
public class CreateUserUseCase
{
    private readonly IUserRepository _userRepository;

    public CreateUserUseCase(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public void Execute(string email)
    {
        var emailAddress = new EmailAddress(email);

        if (_userRepository.GetByEmail(emailAddress) != null)
            throw new InvalidOperationException("Un utilisateur avec cet email existe d√©j√†.");

        var user = new User(Guid.NewGuid(), emailAddress);
        _userRepository.Add(user);
    }
}
```

**Ce qui est important ici**

- Le Use Case **oriente le sc√©nario**
- Les r√®gles m√©tier vivent dans le Domain (`User`, `EmailAddress`)
- La persistance est abstraite via `IUserRepository`
- L‚ÄôInfrastructure interviendra plus tard pour l‚Äôimpl√©mentation

---

## 4.5. Exemple : coordination de plusieurs entit√©s

La couche Application est aussi responsable de la **coordination**.

```csharp
public class PlaceOrderUseCase
{
    private readonly IOrderRepository _orderRepository;
    private readonly IUserRepository _userRepository;

    public PlaceOrderUseCase(IOrderRepository orderRepository, IUserRepository userRepository)
    {
        _orderRepository = orderRepository;
        _userRepository = userRepository;
    }

    public void Execute(Guid userId, List<OrderItem> items)
    {
        var user = _userRepository.GetById(userId)
            ?? throw new InvalidOperationException("Utilisateur introuvable.");

        var order = new Order(items, hasDiscount: false);
        var orderService = new OrderService();
        var total = orderService.CalculateTotal(order);

        // R√®gles applicatives sp√©cifiques (ex : promotions, seuils, notifications‚Ä¶)

        _orderRepository.Add(order);
    }
}
```

üëâ Ici, le Use Case :

- coordonne plusieurs entit√©s
- appelle un service de domaine
- applique √©ventuellement des r√®gles **propres √† l‚Äôapplication**

---

## 4.6. Bonnes pratiques pour la couche Application

Quelques r√®gles simples pour garder une couche Application saine üå± :

- Un Use Case = **une intention m√©tier claire**
- Pas de logique technique
- Toute d√©pendance externe passe par une interface
- Des classes simples, faciles √† lire et √† tester

üëâ Si un Use Case devient trop complexe, c‚Äôest souvent le signe qu‚Äôune r√®gle m√©tier devrait vivre dans le Domain.
